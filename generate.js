const fs = require('fs');
const Path = require('path');
const objdumpParser = require('arm-objdump-parser');
const fnToWrapper = require('./wrapper-generator/function-to-wrapper');

let symbolsFile = process.argv[2];
let className = process.argv[3];
let jsClassName = className;

let jsClassIx = process.argv.indexOf('--js-class-name');
if (jsClassIx !== -1) {
    jsClassName = process.argv[jsClassIx + 1];
}

let libraryName = jsClassName.toLowerCase();
let libNameIx = process.argv.indexOf('--library-name');
if (libNameIx !== -1) {
    libraryName = process.argv[libNameIx + 1];
}

let headerFile = `// @todo: add a reference to the ${className} header here`;
let headerFileIx = process.argv.indexOf('--header-file');
if (headerFileIx !== -1) {
    headerFile = '#include "' + process.argv[headerFileIx + 1] + '"';
}

let createFiles = process.argv.indexOf('--dont-create-files') === -1;

if (className === jsClassName && className.indexOf('<') > -1) {
    console.error('When passing in a generic classname, please also pass in --js-class-name');
    console.error('Usage: node generate.js symbolsfile.txt classname [--js-class-name output-classname --library-name lib-name]');
    process.exit(1);
}

if (!symbolsFile || !className) {
    console.error('Usage: node generate.js symbolsfile.txt classname [--js-class-name output-classname --library-name lib-name]');
    process.exit(1);
}

let symbols = fs.readFileSync(symbolsFile, 'utf-8');
let tree = objdumpParser(symbols);

let obj = tree.nodes.filter(c => c.tag === 'class_type' && c.name === className);
// find the one with most children...
obj.sort((a, b) => b.children.length - a.children.length);
obj = obj[0];
if (!obj) {
    console.error(`Could not find object '${className}'. Are you sure it's linked in?`);
    process.exit(1);
}

try {
    fs.mkdirSync(Path.join(__dirname, 'output'));
}
catch (ex) {}

let folder = Path.join(__dirname, 'output', 'js-mbed-' + libraryName + '-' + Date.now());

// Now we can do interesting stuff...
let fns = obj.children.filter(c => c.tag === 'subprogram' && c.accessibility === '1\t(public)');

let mappedFns = fns.map(fn => fnToWrapper.fnToString(obj, jsClassName, fn, fns)).filter(fn => !!fn);

let members = mappedFns
    .reduce((curr, fn) => {
        curr[fn.name] = curr[fn.name] || [];
        curr[fn.name].push(fn);
        return curr;
    }, {});

let enums = mappedFns
    .reduce((curr, m) => curr.concat(m && m.enums), [])
    .reduce((curr, e) => {
        if (!e) return curr;

        curr[e.name] = e.values;
        return curr;
    }, {});

if (createFiles) {
    fs.mkdirSync(folder);
    fs.mkdirSync(Path.join(folder, 'mbed-js-' + libraryName));
    fs.mkdirSync(Path.join(folder, 'source'));

    fs.writeFileSync(Path.join(folder, 'source', 'mbed-js-' + jsClassName.toLowerCase() + '.cpp'), createCpp(libraryName, className, jsClassName, members, enums, headerFile, fns), 'utf-8');

    // Create the base files (-js.h and lib_*.h)
    fs.writeFileSync(Path.join(folder, 'mbed-js-' + libraryName, 'mbed-js-' + jsClassName.toLowerCase() + '.h'), createJsH(libraryName, className, jsClassName, headerFile), 'utf-8');
    fs.writeFileSync(Path.join(folder, 'mbed-js-' + libraryName, 'mbed-js-' + libraryName + '-lib.h'), createLibH(libraryName, className, jsClassName), 'utf-8');

    fs.writeFileSync(Path.join(folder, 'mbedjs.json'), createMbedJsJson(libraryName, className, jsClassName), 'utf-8');
    fs.writeFileSync(Path.join(folder, 'package.json'), createPackageJson(libraryName, className, jsClassName), 'utf-8');

    console.log('\nDone. Created wrapper in', folder);
    console.log('To add this wrapper to your project:');
    console.log(`\t1. Add the native library to the wrapper ('mbed add http://path-to-native-library')`);
    console.log(`\t2. Add the wrapper to your JS project via 'npm install ${folder} --save --ignore-scripts'`);
}
else {
    console.log('Done. Did not store the wrapper on disk.');
}

function createJsH(libraryName, className, jsClassName, headerFile) {
    let upper = libraryName.toUpperCase();
    return `/* Generated by https://github.com/janjongboom/mbed-js-wrapper-generator */

#ifndef _JERRYSCRIPT_MBED_${upper}_H
#define _JERRYSCRIPT_MBED_${upper}_H

#include "jerryscript-mbed-library-registry/wrap_tools.h"

${headerFile}

DECLARE_CLASS_CONSTRUCTOR(${jsClassName});
jerry_value_t mbed_js_wrap_native_object(${className}* ptr);

#endif // _JERRYSCRIPT_MBED_${upper}_H
`;
}

function createLibH(libraryName, className, jsClassName) {
    let upper = libraryName.toUpperCase();

    return `/* Generated by https://github.com/janjongboom/mbed-js-wrapper-generator */

#ifndef _JERRYSCRIPT_MBED_LIB_${upper}_H
#define _JERRYSCRIPT_MBED_LIB_${upper}_H

#include "mbed-js-${libraryName}/mbed-js-${libraryName}.h"
#include "jerryscript-mbed-library-registry/wrap_tools.h"

void mbed_js_${jsClassName}_setup();

DECLARE_JS_WRAPPER_REGISTRATION (${libraryName})
{
    REGISTER_CLASS_CONSTRUCTOR(${jsClassName});
    mbed_js_${jsClassName}_setup();
}

#endif // _JERRYSCRIPT_MBED_LIB_${upper}_H
`;
}

function createCpp(libraryName, className, jsClassName, members, enums, headerFile, allFns) {
    let enumText = Object.keys(enums).map((name, ix) => {
        let values = enums[name];

        let decl = values.map(v => {
            return `jerry_set_property(enum_obj, jerry_create_string((const jerry_char_t*)"${v}"), jerry_create_number((double) ${v}));`
        }).map(v => '        ' + v).join('\n');

        let text = `
    {
        jerry_value_t enum_obj = jerry_create_object();

        jerry_value_t enum_val;
        jerry_value_t enum_key;

${decl}

        jerry_value_t global_obj = jerry_get_global_object();
        jerry_set_property(global_obj, jerry_create_string((const jerry_char_t*)"${name}"), enum_obj);
    }`;

        return text;
    }).join('\n\n');

    let body = Object.keys(members).filter(name => name !== 'ctor').map(name => {
        let fnArr = members[name];
        let argsLength = fnArr.map(f => `(args_count == ${f.argsLength})`).join(' || ');

        let fnBody = fnArr.map(fn => {
            return `if (args_count == ${fn.argsLength}) {\n${fn.body}\n}`;
        }).join('\n');

        fnBody = fnBody.split('\n').map(l => '    ' + l).join('\n');

        return `/**
 * ${jsClassName}#${name} (native JavaScript method)
 */
DECLARE_CLASS_FUNCTION(${jsClassName}, ${name}) {
    CHECK_ARGUMENT_COUNT(${jsClassName}, ${name}, ${argsLength});

${fnBody}
}`
    }).join('\n\n');

    let dtor = fnToWrapper.createDestructor(obj, jsClassName);
    let wrapper = fnToWrapper.createNativeWrapper(obj, jsClassName, allFns);

    let ctor = Object.keys(members).filter(name => name === 'ctor').map(name => {
        let fnArr = members[name];
        let argsLength = fnArr.map(f => `(args_count == ${f.argsLength})`).join(' || ');

        let fnBody = fnArr.map(fn => {
            return `if (args_count == ${fn.argsLength}) {\n${fn.body}\n}`;
        }).join('\n');

        fnBody = fnBody.split('\n').map(l => '    ' + l).join('\n');

        return `/**
 * ${jsClassName} (native JavaScript constructor)
 */
DECLARE_CLASS_CONSTRUCTOR(${jsClassName}) {
    CHECK_ARGUMENT_COUNT(${jsClassName}, __constructor, ${argsLength});

${fnBody}
}`
    }).join('\n\n');

    return `/* Generated by https://github.com/janjongboom/mbed-js-wrapper-generator */

#include "jerryscript-mbed-util/logging.h"
#include "jerryscript-mbed-library-registry/wrap_tools.h"

${headerFile}

${body}

${dtor}

${wrapper}

${ctor}

void mbed_js_${jsClassName}_setup() {
${enumText}
}
`;
}

function createMbedJsJson(libraryName, className, jsClassName) {
return `{
    "source": [
        "."
    ],
    "includes": [
        "mbed-js-${libraryName}/mbed-js-${libraryName}-lib.h"
	],
    "name": "${libraryName}"
}
`;
}

function createPackageJson(libraryName, className, jsClassName) {
return `{
    "name": "mbed-js-${libraryName}",
    "version": "1.0.0",
    "scripts": {
        "postinstall": "echo 'ROOT=.' > .mbed && mbed deploy"
    }
}
`;
}
